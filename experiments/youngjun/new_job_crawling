import mysql.connector
import requests
import xml.etree.ElementTree as ET
import json
import re
import schedule
import time
from dotenv import load_dotenv
import os

# 🔐 환경 변수 로드
load_dotenv()

# ==========================
#  🔑 Worknet API KEY 직접 입력
# ==========================
WORKNET_API_KEY = "d021e94c-74ff-4fcf-8ed5-576898fdd9a2"

# ==========================
#  문자열 정규화 (기업명 비교용)
# ==========================
def _normalize(s: str) -> str:
    """기업명/별칭을 단순화하여 비교 가능하게 정규화"""
    if not s:
        return ""
    s = re.sub(r"\(주\)", "", s)      
    s = re.sub(r"[\s·•\-_/]", "", s)  
    s = re.sub(r"[^\w가-힣]", "", s)    
    return s.lower()

# ==========================
#  관심 기업 세트 구축
# ==========================
def build_interest_set(companies, aliases):
    """DB에서 가져온 기업명 + 별칭을 정규화하여 Set으로 만듦"""
    norm_set = set()
    for c in companies:
        norm_set.add(_normalize(c))
    for a in aliases:
        if a:
            norm_set.add(_normalize(a))
    return norm_set

# ==========================
#  관심 기업 매칭 함수
# ==========================
def is_interest_company(company_name: str, interest_norm_set) -> bool:
    """채용공고 기업명이 관심기업 리스트에 해당하는지 검사"""
    n = _normalize(company_name)
    if not n:
        return False
    if n in interest_norm_set:
        return True
    for target in interest_norm_set:
        if target in n or n in target:
            return True
    return False

# ==========================
#  DB 설정 (사용자가 제공한 정보로 직접 설정)
# ==========================
db_config = {
    'host': 'localhost',
    'user': 'root', 
    'password': 'dldudwns01~', 
    'database': 'mysql'
}

# ==========================
#  DB에서 관심 기업 불러오기
# ==========================
def fetch_companies_from_db():
    print("\n🔍 DB에서 관심 기업 불러오기")
    companies, aliases = [], []
    try:
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()
        cursor.execute("SELECT name, alias FROM companies")
        rows = cursor.fetchall()
        companies = [row[0] for row in rows if row[0]]
        aliases = [row[1] for row in rows if len(row) > 1 and row[1]]
        print(f"✅ DB 기업명 {len(companies)}개, 별칭 {len([a for a in aliases if a])}개 불러옴")
    except mysql.connector.Error as err:
        print(f"❌ DB 오류: {err}")
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()
    return companies, aliases

# ==========================
#  API 호출 및 관심기업 필터링
# ==========================
def fetch_and_filter_jobs(companies, aliases):
    if not companies:
        print("❌ 관심 기업이 없습니다.")
        return []

    url = "https://www.work24.go.kr/cm/openApi/call/wk/callOpenApiSvcInfo210L21.do" 
    all_raw_jobs = []
    interest_norm_set = build_interest_set(companies, aliases)

    print("\n📦 '채용정보' API 수집 시작\n")

    for page in range(1, 4):
        params = {
            "authKey": WORKNET_API_KEY,  
            "callTp": "L",
            "returnType": "XML",
            "startPage": str(page),
            "display": "100"
        }

        try:
            response = requests.get(url, params=params)
            response.raise_for_status()

            root = ET.fromstring(response.content)

            for job_item in root.findall(".//dhsOpenEmpInfo"):
                company_name = job_item.findtext("empBusiNm") or ""

                if not is_interest_company(company_name, interest_norm_set):
                    continue
                
                print(f"🎯 매칭된 기업: {company_name}")

                job_data = {
                    "company_name": company_name,
                    "job_title": job_item.findtext("empWantedTitle"),
                    "employment_type": job_item.findtext("empWantedTypeNm"),
                    "start_date": job_item.findtext("empWantedStdt"),
                    "end_date": job_item.findtext("empWantedEndt"),
                    "company_type": job_item.findtext("coClcdNm"),
                    "company_logo": job_item.findtext("regLogImgNm"),
                    "apply_link": job_item.findtext("empWantedHomepgDetail"),
                    "job_id": job_item.findtext("wantedAuthNo") 
                }
                all_raw_jobs.append(job_data)

        except Exception as e:
            print(f"❌ API 오류 (페이지 {page}): {e}")
            continue

    print(f"\n📊 관심기업 공고 수집 결과: {len(all_raw_jobs)}건")
    return all_raw_jobs

# ==========================
#  기존 DB에서 job_id 목록 가져오기 (중복 방지용)
# ==========================
def fetch_existing_job_ids_from_db():
    """DB에서 이미 존재하는 job_id 목록을 가져옵니다."""
    existing_job_ids = set()
    try:
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()
        cursor.execute("SELECT job_id FROM jobs")
        rows = cursor.fetchall()
        existing_job_ids = {row[0] for row in rows}
    except mysql.connector.Error as err:
        print(f"❌ DB 오류: {err}")
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()
    return existing_job_ids

# ==========================
#  DB에 공고 저장 (업데이트 및 삽입, 중복 처리)
# ==========================
def upsert_jobs_to_db(data):
    if not data:
        print("💡 수집된 공고가 없어 DB에 저장하지 않습니다.")
        return

    existing_job_ids = fetch_existing_job_ids_from_db()  # 기존 job_id 목록을 가져옵니다.

    # 중복되지 않은 새로운 공고만 DB에 추가합니다.
    new_jobs = [job for job in data if job['job_id'] not in existing_job_ids]

    if not new_jobs:
        print("💡 새로운 공고가 없습니다. 기존 공고만 갱신됩니다.")
        return

    try:
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()

        job_tuples = [
            (
                job.get('company_name'),
                job.get('job_title'),
                job.get('employment_type'),
                job.get('start_date'),
                job.get('end_date'),
                job.get('company_type'),
                job.get('company_logo'),
                job.get('apply_link'),
                job.get('job_id')
            ) for job in new_jobs
        ]

        # ✅ INSERT 쿼리에 job_id 열 추가, ON DUPLICATE KEY UPDATE로 기존 데이터 갱신
        query = """
            INSERT INTO jobs (
                company_name, job_title, employment_type, start_date,
                end_date, company_type, company_logo, apply_link, job_id
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            ON DUPLICATE KEY UPDATE
                company_name=VALUES(company_name),
                job_title=VALUES(job_title),
                employment_type=VALUES(employment_type),
                start_date=VALUES(start_date),
                end_date=VALUES(end_date),
                company_type=VALUES(company_type),
                company_logo=VALUES(company_logo),
                apply_link=VALUES(apply_link);
        """

        cursor.executemany(query, job_tuples)
        conn.commit()

        print(f"✅ 총 {cursor.rowcount}개 공고가 DB에 성공적으로 저장되었습니다 (신규 + 갱신).")

        # 신규 공고와 갱신된 공고 출력
        print("\n🎉 추가된 신규 공고:")
        for job in new_jobs:
            print(f"- {job['company_name']} - {job['job_title']} (ID: {job['job_id']})")

    except mysql.connector.Error as err:
        print(f"❌ DB 저장 오류: {err}")
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()

def create_jobs_table():
    conn = None
    try:
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()
        
        create_table_query = """
            CREATE TABLE IF NOT EXISTS jobs (
                id INT AUTO_INCREMENT PRIMARY KEY,
                company_name VARCHAR(255),
                job_title VARCHAR(255),
                employment_type VARCHAR(255),
                start_date VARCHAR(255),
                end_date VARCHAR(255),
                company_type VARCHAR(255),
                company_logo VARCHAR(255),
                apply_link VARCHAR(255),
                job_id VARCHAR(255) UNIQUE, 
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """
        cursor.execute(create_table_query)
        print("✅ 'jobs' 테이블이 성공적으로 생성되었거나 이미 존재합니다.")
    except mysql.connector.Error as err:
        print(f"❌ 테이블 생성 오류: {err}")
    finally:
        if conn and conn.is_connected():
            cursor.close()
            conn.close()

# ==========================
#  스케줄러 설정 (10시, 14시, 19시에 API 호출)
# ==========================
def job():
    print("✅ 10:00, 14:00, 19:00, API 호출 시작...")

    companies, aliases = fetch_companies_from_db()
    raw_jobs = fetch_and_filter_jobs(companies, aliases)
    
    if raw_jobs:
        upsert_jobs_to_db(raw_jobs)
    else:
        print("💡 수집된 새로운 공고가 없습니다.")
    
# 10시, 14시, 19시마다 API 호출
schedule.every().day.at("10:00").do(job)
schedule.every().day.at("14:00").do(job)
schedule.every().day.at("19:00").do(job)

# ==========================
#  메인 실행
# ==========================
def main():
    print("\n=== 📈 Job Crawling 에이전트 실행 시작 ===")
    create_jobs_table()

    # 1. 첫 번째 실행 시 API 호출 (수동 실행)
    companies, aliases = fetch_companies_from_db()
    raw_jobs = fetch_and_filter_jobs(companies, aliases)

    if raw_jobs:
        upsert_jobs_to_db(raw_jobs)  # 첫 실행에서 바로 호출하여 DB 업데이트
        print("\n🎉 채용공고 수집 완료")
    else:
        print("\n💡 관심 기업 공고 없음")

    print("\n=== 🏁 Job Crawling 에이전트 실행 중 ===")
    
    # 2. 스케줄러가 계속 돌아가도록
    while True:
        schedule.run_pending()  # 스케줄러가 실행될 때 대기
        time.sleep(1)

if __name__ == "__main__":
    main()
