import mysql.connector
import requests
import xml.etree.ElementTree as ET
import schedule
import time
from dotenv import load_dotenv
import os

# ğŸ” í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
load_dotenv()

# ==========================
#  ğŸ”‘ Worknet API KEY
# ==========================
WORKNET_API_KEY = "d021e94c-74ff-4fcf-8ed5-576898fdd9a2"

# ==========================
#  DB ì„¤ì • (ì‚¬ìš©ì ì œê³µ ì •ë³´ ê·¸ëŒ€ë¡œ)
# ==========================
db_config = {
    'host': 'localhost',
    'user': 'root', 
    'password': 'dldudwns01~', 
    'database': 'mysql'
}

# ==========================
#  API í˜¸ì¶œ ë° ì „ì²´ ê³µê³  ìˆ˜ì§‘
# ==========================
def fetch_all_jobs():
    url = "https://www.work24.go.kr/cm/openApi/call/wk/callOpenApiSvcInfo210L21.do" 
    all_jobs = []

    for page in range(1, 10):  # í˜ì´ì§€ ìˆ˜ í•„ìš”ì— ë”°ë¼ ì¡°ì • ê°€ëŠ¥
        params = {
            "authKey": WORKNET_API_KEY,
            "callTp": "L",
            "returnType": "XML",
            "startPage": str(page),
            "display": "100"
        }

        try:
            response = requests.get(url, params=params)
            response.raise_for_status()
            root = ET.fromstring(response.content)

            for job_item in root.findall(".//dhsOpenEmpInfo"):
                # ğŸ”¹ job_idê°€ ì—†ìœ¼ë©´ íšŒì‚¬ëª…+ê³µê³ ëª… ì¡°í•©ìœ¼ë¡œ ê³ ìœ ê°’ ìƒì„±
                raw_job_id = job_item.findtext("wantedAuthNo")
                job_id = raw_job_id if raw_job_id else f"NOID_{job_item.findtext('empWantedTitle')}_{job_item.findtext('empBusiNm')}"

                job_data = {
                    "company_name": job_item.findtext("empBusiNm"),
                    "job_title": job_item.findtext("empWantedTitle"),
                    "employment_type": job_item.findtext("empWantedTypeNm"),
                    "start_date": job_item.findtext("empWantedStdt"),
                    "end_date": job_item.findtext("empWantedEndt"),
                    "company_type": job_item.findtext("coClcdNm"),
                    "company_logo": job_item.findtext("regLogImgNm"),
                    "apply_link": job_item.findtext("empWantedHomepgDetail"),
                    "job_id": job_id
                }
                all_jobs.append(job_data)

        except Exception as e:
            print(f"âŒ API ì˜¤ë¥˜ (í˜ì´ì§€ {page}): {e}")
            continue

    print(f"\nğŸ“Š ì „ì²´ ê³µê³  ìˆ˜ì§‘ ì™„ë£Œ: {len(all_jobs)}ê±´")
    return all_jobs

# ==========================
# DBì— ì‹ ê·œ ê³µê³ ë§Œ ì €ì¥ + ì—…ë°ì´íŠ¸
# ==========================
def upsert_jobs_to_db(jobs):
    if not jobs:
        print("ğŸ’¡ ìˆ˜ì§‘ëœ ê³µê³ ê°€ ì—†ìŠµë‹ˆë‹¤.")
        return

    try:
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()

        job_tuples = [
            (
                job.get('company_name'),
                job.get('job_title'),
                job.get('employment_type'),
                job.get('start_date'),
                job.get('end_date'),
                job.get('company_type'),
                job.get('company_logo'),
                job.get('apply_link'),
                job.get('job_id')
            ) for job in jobs
        ]

        # ğŸ”¹ ON DUPLICATE KEY UPDATE ì‚¬ìš© â†’ job_id ì¤‘ë³µ ì‹œ ê¸°ì¡´ ë°ì´í„° ì—…ë°ì´íŠ¸
        query = """
            INSERT INTO jobs (
                company_name, job_title, employment_type, start_date,
                end_date, company_type, company_logo, apply_link, job_id
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            ON DUPLICATE KEY UPDATE
                company_name = VALUES(company_name),
                job_title = VALUES(job_title),
                employment_type = VALUES(employment_type),
                start_date = VALUES(start_date),
                end_date = VALUES(end_date),
                company_type = VALUES(company_type),
                company_logo = VALUES(company_logo),
                apply_link = VALUES(apply_link)
        """

        cursor.executemany(query, job_tuples)
        conn.commit()

        print(f"âœ… {cursor.rowcount}ê±´ ì‹ ê·œ/ì—…ë°ì´íŠ¸ ê³µê³  DB ì²˜ë¦¬ ì™„ë£Œ")

    except mysql.connector.Error as err:
        print(f"âŒ DB ì €ì¥ ì˜¤ë¥˜: {err}")
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()

# ==========================
#  jobs í…Œì´ë¸” ìƒì„±
# ==========================
def create_jobs_table():
    try:
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()
        create_table_query = """
            CREATE TABLE IF NOT EXISTS jobs (
                id INT AUTO_INCREMENT PRIMARY KEY,
                company_name VARCHAR(255),
                job_title VARCHAR(255),
                employment_type VARCHAR(255),
                start_date VARCHAR(255),
                end_date VARCHAR(255),
                company_type VARCHAR(255),
                company_logo VARCHAR(255),
                apply_link VARCHAR(255),
                job_id VARCHAR(255) UNIQUE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
        """
        cursor.execute(create_table_query)
        print("âœ… 'jobs' í…Œì´ë¸” ìƒì„± ì™„ë£Œ ë˜ëŠ” ì´ë¯¸ ì¡´ì¬í•¨")
    except mysql.connector.Error as err:
        print(f"âŒ í…Œì´ë¸” ìƒì„± ì˜¤ë¥˜: {err}")
    finally:
        if 'conn' in locals() and conn.is_connected():
            cursor.close()
            conn.close()

# ==========================
#  ìŠ¤ì¼€ì¤„ëŸ¬ job
# ==========================
def job():
    print("ğŸ•’ ì›Œí¬ë„· ê³µê³  ìˆ˜ì§‘ ì‹œì‘...")
    all_jobs = fetch_all_jobs()
    upsert_jobs_to_db(all_jobs)
    print("ğŸŸ¢ ìˆ˜ì§‘ ì™„ë£Œ\n=== ğŸ•’ ìŠ¤ì¼€ì¤„ëŸ¬ ëŒ€ê¸° ì¤‘ ===")

# ==========================
#  ë©”ì¸ ì‹¤í–‰
# ==========================
def main():
    create_jobs_table()

    # ì²« ì‹¤í–‰
    job()

    # ìŠ¤ì¼€ì¤„ëŸ¬ 10:00, 14:00, 19:00
    schedule.every().day.at("10:00").do(job)
    schedule.every().day.at("14:00").do(job)
    schedule.every().day.at("19:00").do(job)

    while True:
        schedule.run_pending()
        time.sleep(1)

if __name__ == "__main__":
    main()
